From cc7c531c0a828fcb600de2894fa3187b56ce7d70 Mon Sep 17 00:00:00 2001
From: Sudipta Pandit <sudpandit@microsoft.com>
Date: Fri, 12 Sep 2025 11:44:09 +0530
Subject: [PATCH] add docker seccomp profile test (#3994)

---
 lisa/tools/docker.py                          |  59 ++++++++--
 .../TestScripts/deny_chmod_seccomp.json       |   9 ++
 microsoft/testsuites/docker/dockersuite.py    | 106 +++++++++++++-----
 3 files changed, 134 insertions(+), 40 deletions(-)
 create mode 100644 microsoft/testsuites/docker/TestScripts/deny_chmod_seccomp.json

diff --git a/lisa/tools/docker.py b/lisa/tools/docker.py
index 4ca4dee362..566618a1fa 100644
--- a/lisa/tools/docker.py
+++ b/lisa/tools/docker.py
@@ -1,5 +1,7 @@
 # Copyright (c) Microsoft Corporation.
 # Licensed under the MIT license.
+from typing import Optional
+
 from retry import retry
 
 from lisa.base_tools import Service, Wget
@@ -11,6 +13,7 @@
     RepoNotExistException,
     UnsupportedDistroException,
 )
+from lisa.util.process import ExecutableResult
 
 
 class Docker(Tool):
@@ -43,24 +46,62 @@ def remove_container(self, container_name: str) -> None:
         self._log.debug(f"Removing Docker Container {container_name}")
         self.run(f"rm {container_name}", sudo=True, force_run=True)
 
+    def pull_image(self, image: str, timeout: int = 600) -> None:
+        self.run(
+            f"pull {image}",
+            sudo=True,
+            force_run=True,
+            timeout=timeout,
+            expected_exit_code=0,
+            expected_exit_code_failure_message=f"Failed to pull image {image}",
+        )
+
     def remove_image(self, image_name: str) -> None:
         self._log.debug(f"Removing Docker Image {image_name}")
         self.run(f"rmi {image_name}", sudo=True, force_run=True)
 
+    def info(self) -> str:
+        return self.run("info", sudo=True, force_run=True).stdout
+
     def run_container(
         self,
         image_name: str,
-        container_name: str,
-        docker_run_output: str,
-    ) -> None:
-        self.run(
-            f"run --name {container_name} {image_name} > {docker_run_output} 2>&1",
-            shell=True,
+        ephemeral: bool = True,
+        container_name: Optional[str] = None,
+        command: Optional[str] = None,
+        extra_args: Optional[str] = None,
+        expected_exit_code: Optional[int] = 0,
+    ) -> ExecutableResult:
+        """
+        Run a container using `docker run`
+
+        :param image_name: Name of the Docker image to run
+        :param ephemeral: Whether the container should be auto removed after exit.
+        :param container_name: Optional name for the container
+        :param command: Optional command to run inside the container
+        :param extra_args: Optional extra arguments to pass to the docker run command
+        :param expected_exit_code: Expected exit code for the docker run command
+        """
+
+        parts = ["run"]
+        if ephemeral:
+            parts.append("--rm")
+        if extra_args:
+            parts.append(extra_args)
+        if container_name:
+            parts.append(f"--name {container_name}")
+        parts.append(image_name)
+        if command:
+            parts.append(command)
+        cmd = " ".join(parts)
+
+        return self.run(
+            cmd,
             sudo=True,
-            cwd=self.node.working_path,
+            shell=True,
             force_run=True,
-            expected_exit_code=0,
-            expected_exit_code_failure_message="Docker run failed.",
+            expected_exit_code=expected_exit_code,
+            expected_exit_code_failure_message="Docker run failed",
         )
 
     def start(self) -> None:
diff --git a/microsoft/testsuites/docker/TestScripts/deny_chmod_seccomp.json b/microsoft/testsuites/docker/TestScripts/deny_chmod_seccomp.json
new file mode 100644
index 0000000000..3054f1c681
--- /dev/null
+++ b/microsoft/testsuites/docker/TestScripts/deny_chmod_seccomp.json
@@ -0,0 +1,9 @@
+{
+  "defaultAction": "SCMP_ACT_ALLOW",
+  "syscalls": [
+    {
+      "names": ["chmod", "fchmod", "fchmodat"],
+      "action": "SCMP_ACT_ERRNO"
+    }
+  ]
+}
diff --git a/microsoft/testsuites/docker/dockersuite.py b/microsoft/testsuites/docker/dockersuite.py
index 762214de32..9e193846a8 100644
--- a/microsoft/testsuites/docker/dockersuite.py
+++ b/microsoft/testsuites/docker/dockersuite.py
@@ -7,8 +7,14 @@
 
 from assertpy import assert_that
 
-from lisa import Node, TestCaseMetadata, TestSuite, TestSuiteMetadata
-from lisa.operating_system import CentOs, Redhat
+from lisa import (
+    Node,
+    TestCaseMetadata,
+    TestSuite,
+    TestSuiteMetadata,
+    simple_requirement,
+)
+from lisa.operating_system import BSD, CentOs, Redhat, Windows
 from lisa.tools import Docker, DockerCompose
 from lisa.util import SkippedException, UnsupportedDistroException, get_matched_str
 
@@ -81,7 +87,7 @@ def verify_docker_compose_wordpress_app(self, node: Node) -> None:
     )
     def verify_docker_dotnet31_app(self, node: Node) -> None:
         self._execute_docker_test(
-            node, "dotnetimage", "dotnetapp", "Hello World!", "", "dotnet31.Dockerfile"
+            node, "dotnetimage", "Hello World!", "", "dotnet31.Dockerfile"
         )
 
     @TestCaseMetadata(
@@ -98,7 +104,7 @@ def verify_docker_dotnet31_app(self, node: Node) -> None:
     )
     def verify_docker_dotnet50_app(self, node: Node) -> None:
         self._execute_docker_test(
-            node, "dotnetimage", "dotnetapp", "Hello World!", "", "dotnet50.Dockerfile"
+            node, "dotnetimage", "Hello World!", "", "dotnet50.Dockerfile"
         )
 
     @TestCaseMetadata(
@@ -117,7 +123,6 @@ def verify_docker_java_app(self, node: Node) -> None:
         self._execute_docker_test(
             node,
             "javaappimage",
-            "javaapp",
             "Hello world from java",
             "Main.java",
             "java.Dockerfile",
@@ -139,7 +144,6 @@ def verify_docker_python_app(self, node: Node) -> None:
         self._execute_docker_test(
             node,
             "pythonappimage",
-            "pythonapp",
             "Hello world from python",
             "helloworld.py",
             "python.Dockerfile",
@@ -154,51 +158,33 @@ def _execute_docker_test(
         self,
         node: Node,
         docker_image_name: str,
-        docker_container_name: str,
         string_identifier: str,
         prog_src: str,
         dockerfile: str,
     ) -> None:
-        docker_tool = self._verify_and_remove_containers(
-            node, docker_image_name, docker_container_name
-        )
+        docker_tool = self._verify_and_remove_images(node, docker_image_name)
         if prog_src:
             self._copy_to_node(node, prog_src)
         self._copy_to_node(node, dockerfile)
         self._run_and_verify_results(
-            node,
             docker_tool,
             dockerfile,
             docker_image_name,
-            docker_container_name,
             string_identifier,
         )
 
     def _run_and_verify_results(
         self,
-        node: Node,
         docker_tool: Docker,
         dockerfile_name: str,
         docker_image_name: str,
-        docker_container_name: str,
         string_identifier: str,
     ) -> None:
-        docker_run_output_file = "docker_run.log"
-
         docker_tool.build_image(docker_image_name, dockerfile_name)
-        docker_tool.run_container(
-            docker_image_name, docker_container_name, docker_run_output_file
-        )
+        docker_run = docker_tool.run_container(docker_image_name)
         docker_tool.remove_image(docker_image_name)
-        docker_tool.remove_container(docker_container_name)
 
-        docker_run_output = node.execute(
-            f"cat {docker_run_output_file}",
-            sudo=True,
-            expected_exit_code=0,
-            expected_exit_code_failure_message="Docker run output file not found",
-            cwd=node.working_path,
-        ).stdout
+        docker_run_output = (docker_run.stdout + docker_run.stderr).strip()
         assert_that(docker_run_output).described_as(
             "The container didn't output expected result. "
             "There may have been errors when the container was run. "
@@ -212,9 +198,7 @@ def _skip_if_not_supported(self, node: Node) -> None:
                 f"Test not supported for RH/CentOS {node.os.information.release}"
             )
 
-    def _verify_and_remove_containers(
-        self, node: Node, docker_image_name: str, docker_container_name: str
-    ) -> Docker:
+    def _verify_and_remove_images(self, node: Node, docker_image_name: str) -> Docker:
         self._skip_if_not_supported(node)
         try:
             docker_tool = node.tools[Docker]
@@ -222,7 +206,6 @@ def _verify_and_remove_containers(
             raise SkippedException(e)
         self._verify_docker_engine(node)
         docker_tool.remove_image(docker_image_name)
-        docker_tool.remove_container(docker_container_name)
         return docker_tool
 
     def _verify_docker_engine(self, node: Node) -> None:
@@ -261,3 +244,64 @@ def _verify_docker_engine(self, node: Node) -> None:
             "Fail to run docker run hello-world"
         ).is_equal_to(0)
         node.log.debug(f"VerifyDockerEngine: hello-world output - {result.stdout}")
+
+    @TestCaseMetadata(
+        description="""
+            Verifies a custom Docker seccomp profile is applied and enforced.
+
+            Steps:
+            1. Install Docker on the target node
+            2. Copy the custom seccomp profile that explicitly denies the chmod syscall
+            3. Start a container with this custom seccomp profile and try to run chmod;
+               the command should fail, proving the profile is enforced
+            4. Start another container without the custom profile and run the same chmod
+               command; this time it should succeed, proving the restriction only comes
+               from the profile
+        """,
+        priority=2,
+        requirement=simple_requirement(unsupported_os=[Windows, BSD]),
+    )
+    def verify_docker_seccomp_profile(self, node: Node) -> None:
+        docker_tool = node.tools[Docker]
+        docker_tool.pull_image("alpine:latest")
+        if "seccomp" not in docker_tool.info().lower():
+            raise SkippedException("Seccomp not supported/enabled on this Docker host")
+
+        # Test with profile: expect failure
+        self._copy_to_node(node, "deny_chmod_seccomp.json")
+        profile_path = node.working_path / "deny_chmod_seccomp.json"
+
+        test_cmd = "sh -c 'touch test_file && chmod 600 test_file'"
+        denied = docker_tool.run_container(
+            "alpine:latest",
+            command=test_cmd,
+            extra_args=f"--security-opt seccomp={profile_path}",
+            expected_exit_code=None,
+        )
+        assert_that(denied.exit_code).described_as(
+            "chmod unexpectedly succeeded under denied seccomp profile"
+        ).is_not_equal_to(0)
+        denied_output = (denied.stdout + denied.stderr).lower()
+        assert_that(
+            any(
+                x in denied_output
+                for x in (
+                    "operation not permitted",
+                    "eperm",
+                )
+            )
+        ).described_as(
+            "Did not find expected seccomp denial indicator"
+            " (Operation not permitted/EPERM)"
+        ).is_true()
+
+        # Test without profile: expect success
+        allowed = docker_tool.run_container(
+            "alpine:latest",
+            command=test_cmd,
+            expected_exit_code=0,
+        )
+        allowed_output = (allowed.stdout + allowed.stderr).lower()
+        assert_that(allowed_output).described_as(
+            "Baseline run (no seccomp profile) unexpectedly showed denial text"
+        ).does_not_contain("operation not permitted").does_not_contain("eperm")
